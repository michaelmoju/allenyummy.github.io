[ { "title": "Weekly Progress (49th / 2021)", "url": "/posts/49th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-11-29 09:00:00 +0800", "snippet": "上週五收到 AICS 台北 offer，現在正在等新加坡的 offer，不過忐忑的心可以稍稍再放心一些了！這週要來好好整理新租屋的地方！" }, { "title": "Weekly Progress (48th / 2021)", "url": "/posts/48th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-11-22 22:00:00 +0800", "snippet": "2021.11.22這週一面試 Google，Phone Interview 關卡。我撰寫這篇文章的時候，是我已經拿到 on-site interview 資格了！沒想到我挺進到這一關了，實在是可喜可賀，慶幸自己平常有好好刷題，培養面試的感覺。但我也不抱持著能夠拿到 offer 的心情來參與面試，因爲畢竟知道自己程度大致落在哪裡，這次就是去拿個面試經驗，並與身邊好友們分享，希望大家能夠一起向前邁進。不過，這次 Google 面試官給我的評價，跟黃泰一給我的評價，幾乎是雷同的。他回饋了幾點： 資料結構與演算法是熟悉的，且具有潛力。 解題想法、溝通能力是不錯的。 解題效率不夠快。第三點恰恰與黃泰一說「我實作不夠熟練，不像資工系那般純熟」相吻合。從面試官的回饋去修正我的問題，調整方向再向前，是我這次轉職最主要的初衷，我要好好想想該如何做修正了！Google 人資因為聽到我有打算去單車環島，立馬幫我安排這週三面試，共四關 (3關 coding、1關 behavior)這面試的緊湊度跟 AICS 挺像的，實在有些吃不消，只能告訴自己：「嘗試總是好的，沒有什麼好失去的。」除了面試之外，今天去找了台北士林一帶的租屋。有趣的是，遇見了一對尼泊爾妻、阿拉伯夫、一位女兒、一位遠在英國念碩士的兒子。他們因為疫情關係到台灣工作，目前打算出租其中一間房間，幫忙付房租。我心想，是不是因為老天爺知道我打算接受 AICS 在新加坡的 offer，給我來個文化衝擊小試驗，讓我提前適應這樣的環境。總之，我打算租了，順便練習英文。2021.11.24今天跟新加坡的 Google 人資詳談，也許會在一個月後安排 on-site interview，但也有可能跟之前一樣，position 關閉。但最近生活有了變調，需要趕緊安排妥善才有餘力去面試。事實上，我需要一些時間準備英文…" }, { "title": "Weekly Progress (47th / 2021)", "url": "/posts/47th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-11-17 09:00:00 +0800", "snippet": "三面完 AICS 之後，黃泰一對我的評價是「雖然我不像資工系的人對於寫扣那麼純熟，但是至少我有在進步。」這是對我今年年初開始準備面試到今年年底，一個非常重要的鼓舞。這段時間以來，我不是在原地踏步的！一年多前的自己，還是個碩畢新鮮人，今日拿到的三個 offer，都不是當初的我能夠拿下的！我好開心也慶幸當初自己下定決心要好好準備，時時激勵自己「Tiny Changes, Remarkable Results」，如今得以驗證，不過，我不能因此而自滿，路還很遙遠，走好每一步，做好每次的決策，抓緊每次的機會，我會成功的！我會到我想去的地方看看的！這週去新竹找房之餘，意外獲得 AICS 新加坡海外工作的機會以及 Google 面試邀約，讓我重新思考是不是要連續兩次放棄發哥。感受上，如果不去新加坡的話，未來的我一定會後悔，甚至，我現在就可以想像我已經在後悔了。每到年底，我都有做年曆的習慣。去年的我在做今年的年歷時，在12月的地方寫下，希望此時的我，已經身處國外，沒想到現在機會就在眼前了，我總不能慫了吧！是吧？江侑倫！好吧，先繼續努力了，下週一要面試 Google，不期不待！這週先不放甘特圖了，變動和變數太多，不容易安排好行程，先採取小碎步姿態，動態調整！" }, { "title": "Weekly Progress (46th / 2021)", "url": "/posts/46th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-11-08 09:00:00 +0800", "snippet": "上週六跟王賀的朋友們去南港運動中心打壁球，因為與我原本的朋友圈有一些距離，談論的話題終於可以遠離「轉職」、「薪資」、「租屋」等等有關於工作的事情，而且能與人群真實的連結，感覺真好！當天晚上，Zoey 突然密我，問我要不要跟 Vanesa 去散個步。上次一起散步，大概可以追溯到9月初了吧！這次突然的邀約，打破將近兩個月的無聲無息。心想，他們終於回來水蓮山莊了，因為我正準備轉職離開，惆悵著不知道何時能跟他們說這件事情。Zoey：我們大概晚上八點多出門Me：okay… 9:15 PM …Zoey: We’ll walk to C6Me: Oh no！給我3分鐘散步聊天，話題大概是圍繞在近況與彼此的焦慮，我也在談話中提到自己11月底前可能會搬離水蓮，但他們說之後可以找個中間點，再一起散個步聊天。聽到他們這樣說，我心情放鬆了許多，因為我不想因為轉職而失去在水蓮認識的朋友。甚至，自從認識他們之後，我心中就產生一個計畫，但一直跨不出去。我希望 Zoey 能擔任我的英文口說老師，雖然她才16歲而已，但她的母語是英文，聽她的口音真是舒服R！等我安頓好，找機會再說吧！意外進入 AICS 二面，去年在一面就卡關，這次挺進第二關，也算是一種進步吧！這週二，加油加油！Ganttgantt title 46-th week (2021) dateFormat YYYY-MM-DD axisFormat %m/%d section Leetcode 204 exercise : done , L1, 2021-11-08, 1d 2063 exercise : done , L2, 2021-11-08, 1d 1137 exercise : done , L3, 2021-11-09, 1d 119 exercise : done , L4, 2021-11-09, 1d 669 exercise : done , L5, 2021-11-09, 1d 1646 exercise : done , L6, 2021-11-09, 1d 1395 exercise : done , L7, 2021-11-10, 1d 2064 exercise : L8, 2021-11-10, 1d 263 exercies : done , L9, 2021-11-11, 1d 264 exercies : L10, 2021-11-12, 1d section Interview : AICS 2-nd : done , I1, 2021-11-09, 1d review dp problems: done , I2, 2021-11-09, 1d" }, { "title": "Weekly Progress (45th / 2021)", "url": "/posts/45th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-11-01 09:00:00 +0800", "snippet": "前兩天週末，女友來找我，我們去了一家之前去過的早午餐店，暢談了好多，讓我找回面試之前的生活步調，好喜歡這樣的聊天！結果這個週末又來了 AICS 和日本東京新創的面試邀約，不同的是，我現在的狀態是拿到 AIlabs 和 MTK 的 offer，狀態轉變成「騎馬找馬」的姿態，時時與自己提醒，不要忘記自己喜歡什麼樣的生活，What’s Important Now，才是 WIN !Ganttgantt title 45-th week (2021) dateFormat YYYY-MM-DD axisFormat %m/%d section Leetcode 684 exercise : done , L1, 2021-11-01, 1d 1135 exercise : done , L2, 2021-11-02, 1d 1136 exercise : L3, 2021-11-03, 1d 323 exercies : L4, 2021-11-04, 1d 1319 exercise : done , L5, 2021-11-05, 1d" }, { "title": "Weekly Progress (44th / 2021)", "url": "/posts/44th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-10-25 14:00:00 +0800", "snippet": "上兩個禮拜專心處理 AILabs 和 MTK 面試，作息整個被打亂，目前雖然還有一家 Garena 正要開始，但是已經拿到 offer 之後，身心舒暢啊啊啊！！不過，還要跟人資談薪資和上工時間，談判技巧練起來！Ganttgantt title 44-th week (2021) dateFormat YYYY-MM-DD axisFormat %m/%d section Leetcode 1557 exercise : done , L1, 2021-10-25, 1d 959 exercise : done , L2, 2021-10-26, 1d 841 exercise : done , L3, 2021-10-27, 1d 547 exercies : done , L4, 2021-10-28, 1d 1466 exercise : done , L5, 2021-10-29, 1d 684 exercise : L6, 2021-10-30, 1d section Blog writing a life post : active, B2, 2021-10-25, 3d" }, { "title": "Weekly Progress (43th / 2021)", "url": "/posts/43th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-10-25 14:00:00 +0800", "snippet": "本週專心處理面試，故無紀錄，但仍有持續刷題！" }, { "title": "Weekly Progress (42th / 2021)", "url": "/posts/42th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-10-13 09:00:00 +0800", "snippet": "國慶假日，週一放假，但我可沒法太放鬆，因為週二要面試 AI Labs、週五要面試 MTK，原本想說利用三天連假，好好充實自己，結果根本是折磨自己，平常就應該好好累積寫文章做紀錄，這種面試時刻就不用臨時抱佛腳了。原訂每刷一題，都要有所紀錄，現在改成，刷的過程中覺得這題應該紀錄的話，再行紀錄。稍微縮減一下寫的份量，我感受到自己還沒辦法卯起來寫文章，有點太硬惹。Ganttgantt title 42-th week (2021) dateFormat YYYY-MM-DD axisFormat %m/%d section Leetcode 2033 exercise : done , L1, 2021-10-04, 1d 2034 exercise : done , L2, 2021-10-05, 1d 2035 exercise : L3, 2021-10-06, 1d section Blog writing a life post : active, B2, 2021-10-06, 3d writing a tech post : active , B4, 2021-10-05, 3d section Interview AI Labs 一面三關 : done , I1, 2021-10-12, 1d MTK 一面一關 : done , I2, 2021-10-15, 1d section Reading Pretrained Models : done , R1, 2021-10-11, 5d" }, { "title": "Weekly Progress (41th / 2021)", "url": "/posts/41th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-10-04 09:00:00 +0800", "snippet": "新的一週，新的開始 !!Ganttgantt title 41-th week (2021) dateFormat YYYY-MM-DD axisFormat %m/%d section Leetcode 877 exercise : done , L1, 2021-10-04, 1d 877 writing : L2, 2021-10-04, 1d 1140 exercise : done , L3, 2021-10-05, 1d 1140 writing : L4, 2021-10-05, 1d 1406 exercise : done , L5, 2021-10-06, 1d 1406 writing : L6, 2021-10-06, 1d 1510 exercise : done , L7, 2021-10-07, 1d 1510 writing : L8, 2021-10-07, 1d 1563 exercise : L9, 2021-10-08, 1d 1563 writing : L10,2021-10-08, 1d 1686 exercise : done , L11,2021-10-09, 1d 1686 writing : L12,2021-10-09, 1d section Blog experience your life: active, B1, 2021-10-04, 7d writing a life post : active, B2, 2021-10-06, 3d reading a paper/tech post: active, B3, 2021-10-04, 5d writing a tech post : active , B4, 2021-10-05, 3d本週臨時接獲 AI Labs 和聯發科的面試邀約，急急忙忙去準備面試內容，這週只刷題，沒紀錄，老天，原諒我…" }, { "title": "15. Three Sum", "url": "/posts/15-three-sum/", "categories": "Leetcode, An-Apple-Per-Day", "tags": "leetcode, medium, array, two-pointers", "date": "2021-09-30 15:00:00 +0800", "snippet": "Leetcode #15題目描述Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.Notice that the solution set must not contain duplicate triplets.白話文運動給定一維數列 nums，找到所有以三個數字的總和恰好為零的不重複組合。題目限制 0 &amp;lt;= nums.length &amp;lt;= 3000 105 &amp;lt;= nums[i] &amp;lt;= 105具體測資Case 1Input: nums = [-1,0,1,2,-1,-4]Output: [[-1,-1,2],[-1,0,1]]Case 2Input: nums = []Output: []Case 3Input: nums = [0]Output: []解題想法暴力法 使用 DFS 遍歷所有三元組組合，一一確認總合是否為零。不過，會遇到 TLE (Time Limit Exceed) 問題。排序 + 雙指標 先排序一維數列。 遍歷該數列，鎖定每個數，使其當一次主角。接著，使用雙指標遍歷尋找其他兩個數。 實際解題Sort + TwoPointersclass Solution: def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]: before_ret = set() ## Using sort (O(NlogN)) can save time (Brute force: O(N^3)) nums = sorted(nums) ## One Target Num and Two Pointers for i, num in enumerate(nums): left = i + 1 right = len(nums) - 1 while left &amp;lt; right: three_sum = num + nums[left] + nums[right] if three_sum == 0: before_ret.add((num, nums[left], nums[right])) left += 1 right -= 1 elif three_sum &amp;gt; 0: right -= 1 else: left += 1 return list(before_ret)複雜度分析 時間複雜度: O(NlogN + N2) = O(N2) 空間複雜度: O(1) 不考慮回傳時的陣列討論區" }, { "title": "為何需要 Word Embedding (詞向量、詞嵌入)", "url": "/posts/%E7%82%BA%E4%BD%95%E9%9C%80%E8%A6%81-Word-Embedding-(%E8%A9%9E%E5%90%91%E9%87%8F-%E8%A9%9E%E5%B5%8C%E5%85%A5)/", "categories": "AI, Natural-Language-Processing, Word-Embedding", "tags": "ai, nlp, word-embedding", "date": "2021-09-29 14:00:00 +0800", "snippet": "不寫出來，就沒印象，凡讀過必忘。有能力檢索自己腦袋中的記憶寶殿，在正確的時間拾起正確的記憶，那是我嚮往的能力。前言至今，自然語言處理中最重要的基石：Word Embedding，其起初的想法與後續的發展皆圍繞在一位語言學家 John Rupert Firth 在 1957 年曾經說過的一句名言： You shall know a word by the company it keeps. (Firth, J. R. 1957)藉由上下文判斷該詞的意義，看似再稀鬆平常不過了，甚至時常在讀英文時，許多讀書技巧也是圍繞著這個道理。但一件事物的本質與意義是由旁物推敲而定，總覺得不那麼紮實可靠。不過，每每用網路上的劍橋辭典查詢英文單字時，總是出現更多英文單字來解釋之，或許，這樣的現象最能解釋 John Rupert Firth 的這句名言吧！我們深知任何語言不過是一連串符號象徵，其背後意義在人腦中如何運算無從得知。企圖用電腦運算來處理語言、理解語言，便必須使用數值來表示這些語言符號，這便是 Word Embedding 的起源。那麼，現在問題變成，該用什麼數值來表示字詞，便是 Word Embedding 最需要探討的議題了。題外話，我認為為何深度學習能在電腦視覺與聲音辨識中，相較於自然語言處理，更能快速取得成功的其中一項因素，因為電腦視覺與聲音辨識的資料本身即是數值，而自然語言的資料是符號，需要額外轉換為適當的數值，發展成本與阻礙更多。One Hot Representation當時，人們想到一種簡單的方式來進行轉換：One Hot Representation。假設擁有一部字典，裡頭只有五個字：「蘋果」、「漂亮」、「台灣」、「日本」、「香蕉」。每個字詞代表為一種維度。 蘋果 = [1, 0, 0, 0, 0] 漂亮 = [0, 1, 0, 0, 0] 台灣 = [0, 0, 1, 0, 0] 日本 = [0, 0, 0, 1, 0] 香蕉 = [0, 0, 0, 0, 1]我們會發現，每個字詞都是正交 (Orthogonal)，換句話說，在這五維空間中，這五個字詞彼此之間的距離是相同的。停下來想一想，這樣合理嗎？舉一個例子來瞧瞧： 台灣出產香蕉，總是外銷日本。 日本種植蘋果，總是外銷台灣。在這兩句話當中，可以發現，台灣與日本、香蕉與蘋果，分別是兩組意義相似的概念。在空間中，直覺上彼此距離應該要彼此相近、與其他字詞的距離應該要相遠才是，而用 One Hot Representation 表示的字詞，彼此距離卻是相同的，這是 One Hot Representation 的缺點：「語義鴻溝」。再來，字典中不單單只有五個字，當裡頭含有五萬字詞時，若使用 One Hot Representation，代表每個字詞須用五萬個維度來表示，且其中 49999 個維度是零、1 個維度是一，計算相當不方便且無效率呢！這是 One Hot Representation 的第二個缺點，「維度災難」。稍作片刻、駐足思考”You shall know a word by the company it keeps.” 一個字詞的意義來自於它身旁的上下文，背後延伸的概念是「擁有相似上下文的字詞，詞義應相似；擁有相異上下文的字詞，詞義應相異」。套用空間概念來思考：「擁有相似上下文的字詞，轉換成 Word Embedding 之後，在空間中的距離應相近；反之，距離應相遠」。那麼，適當的 Word Embedding 應該滿足上述條件，亦是 Hinton 所提及的 Distribution Hypothesis 的全貌。Distribution Representation1986 年，深度學習之父 Hinton，發表一篇論文《Distribution Representations》，提到將每個神經元(維度)表示為一個概念時，叫做 Local Representation，One Hot Representation 是 Local Representation 的一種；另外，提出 Distribution Representation 的概念，每個神經元(維度)可以表示多組概念，每個概念可被多個神經元(維度)所表示&amp;lt;/span。Distribution Representation 一次解決了「語義鴻溝」與「維度災難」兩個問題。其一，這些神經元能透過模型訓練，使其符合 Distribution Hypothesis (擁有相似上下文的字詞，空間中彼此距離相近)；其二，維度(神經元個數)不必因字典大小而無限擴展，相較於 One Hot Representaion 來說，是較低維的向量(少於字典中的字詞數)。自此之後，自然語言處理領域中， 「Word Embedding」、「詞嵌入」、「詞向量」，幾乎都由 Distribution Representation 表示，只是獲得此向量的方式不一，百家齊放。結語Word Embedding，是銜接人類符號與電腦運算的重要橋樑，是深度學習在自然語言處理領域中不可或缺的基石。透過簡單的文章，不只分享自己整理好的知識，也不斷更新自己腦袋中的知識，分享即幫助自己。" }, { "title": "198. House Robber", "url": "/posts/198-house-robber/", "categories": "Leetcode, An-Apple-Per-Day", "tags": "leetcode, medium, dp, dfs, memo, recursive, iterative", "date": "2021-09-28 15:00:00 +0800", "snippet": "Leetcode #198題目描述You are a professional robber planning to rob houses along a street.Each house has a certain amount of money stashed.The only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.白話文運動給定一個數列 nums，其中元素代表每戶家庭所藏有的金錢數量。請回傳在今晚你能偷到的最多的金錢數量是多少。限制：若同時搶奪連續兩戶的金錢，將觸發警鈴，那麼就無法繼續偷錢了！題目限制 1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 400具體測資Case 1Input: nums = [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).Total amount you can rob = 1 + 3 = 4.Case 2Input: nums = [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).Total amount you can rob = 2 + 9 + 1 = 12.解題想法概念尋找遞迴的關係，將問題簡化成子問題，一一突破，得到最終解。每個小偷在當前的家門口，總是有兩個選擇： 決定搶這戶 (i) 吧！那麼，代表除了 i-1 這戶無法搶奪之外，i-2之前獲得的戰利品都可以保留著。 決定不搶這戶 (i)！那麼，代表 i-1 之前獲得的戰利品都可以留在手上。因此，這時候我們只需比較這兩種選擇，哪一個拿到的錢更多。rob(i) = max(nums[i]+rob(i-2), rob(i-1))實際解題Recursive (top-down)class Solution: def rob(self, nums: List[int]) -&amp;gt; int: def rob_sub(i: int) -&amp;gt; int: if i &amp;lt; 0: return 0 return max(nums[i]+rob_sub(i-2), rob_sub(i-1)) n = len(nums) return rob_sub(n-1)Recursive + Memo (top-down)上述方法會重複計算許多次相同的i，可以優化時間複雜度！class Solution: def rob(self, nums: List[int]) -&amp;gt; int: def rob_sub(i: int) -&amp;gt; int: if i &amp;lt; 0: return 0 if i in self.memo: return self.memo[i] res = max(nums[i]+rob_sub(i-2), rob_sub(i-1)) self.memo[i] = res return res n = len(nums) self.memo = dict() return rob_sub(n-1) 時間複雜度：O(N) 空間複雜度：O(N)Iterative + memo (bottom-up)class Solution: def rob(self, nums: List[int]) -&amp;gt; int: n = len(nums) if n &amp;lt; 1: return 0 if n == 1: return nums[0] memo = [0] * n memo[0] = nums[0] memo[1] = max(nums[0], nums[1]) for i in range(2, n): memo[i] = max(memo[i-2]+nums[i], memo[i-1]) return memo[-1] 時間複雜度：O(N) 空間複雜度：O(N)Iterative + N variables (bottom-up)我們可以注意到我們僅需使用到 memo[i-2] 和 memo[i-1] 的數值，不需要去創建一個長度為 n 的 memo，因此可以優化空間複雜度。class Solution: def rob(self, nums: List[int]) -&amp;gt; int: n = len(nums) if n &amp;lt; 1: return 0 if n == 1: return nums[0] prev1 = 0 prev2 = 0 for num in nums: tmp = prev1 prev1 = max(num+prev2, prev1) prev2 = tmp return prev1 時間複雜度：O(N) 空間複雜度：O(1)複雜度分析請參照上方各解法之細節。討論區這篇完美解析 DP 的問題，希望自己也能循序解決類似的問題！" }, { "title": "Weekly Progress (40th / 2021)", "url": "/posts/40th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-09-27 15:00:00 +0800", "snippet": "上週認認真真地體會了一下生活，恰好週末有空閒時間，給烏龜們一個完美的過濾器和浮島、跟我的老天鵝成員們吃了一頓飯、去同學家聊天，當然，也寫了一些剖析自己的文章，但還沒完全寫完，不過其他有關於刷題或是技術的文章，產出狀況還不錯，繼續保持！認真地包裝自己後，馬上收到其他公司的面試邀約，面試面起來！！Ganttgantt title 40-th week (2021) dateFormat YYYY-MM-DD axisFormat %m/%d section Leetcode 198 exercise : done , L1, 2021-09-26, 1d 198 writing : done , L2, 2021-09-26, 1d 213 exercise : done , L3, 2021-09-27, 1d 213 writing : active, L4, 2021-09-27, 1d 337 exercise : done , L5, 2021-09-28, 1d 337 writing : L6, 2021-09-28, 1d 15 exercise : done , L7, 2021-09-29, 1d 15 writing : done , L8, 2021-09-29, 1d 16 exercise : done , L9, 2021-09-30, 1d 16 writing : L10,2021-09-30, 1d 18 exercise : done , L11,2021-10-01, 1d 18 writing : L12,2021-10-01, 1d 454 exercise : done , L13,2021-10-02, 1d 454 writing : L14,2021-10-02, 1d section Blog experience your life: done , B1, 2021-09-27, 7d writing a life post : active, B2, 2021-09-27, 3d reading a paper/tech post: done, B3, 2021-09-28, 5d writing a tech post : done , B4, 2021-09-29, 3d本週週末女友來找我，我們做了好多事情，一起下廚料理、租 irent 去望幽谷看海吹海風、一起逛好市多、一起去吃日本料理。我們也互相分享了好多事情，這週末好放鬆，完完全全地充電，雖然有些該完成的寫作沒完成，但是著著實實地 “experience my life”。" }, { "title": "東京大學 ELYZA AI 用 3 行總結任何一句話", "url": "/posts/%E6%9D%B1%E4%BA%AC%E5%A4%A7%E5%AD%B8-ELYZA-AI-%E7%94%A8-3-%E8%A1%8C%E7%B8%BD%E7%B5%90%E4%BB%BB%E4%BD%95%E4%B8%80%E5%8F%A5%E8%A9%B1/", "categories": "AI, Natural-Language-Processing, Text-Summarization", "tags": "ai, nlp, text-summarization", "date": "2021-09-24 10:45:00 +0800", "snippet": "部長傳來 elyza 的連結到公司的 slack 群組。下了班、吃完飯，心滿意足地坐在家裡隨意翻看了一下。隨時打開自己的腦袋，接收新知。前言在自然語言處理領域中，文本摘要 (Text Summarization)是其中一項任務，旨在從一段長篇文本中，生成出一段精準的、有意義的結論。日本東京大學松尾實驗室深度學習專業組 “ELYZA” 發布了一個文本摘要範例小網頁，稱作ELYZA DIGEST，只要在紅色區域輸入文本或是網址，便可為您捎來三句話來總結長文。而且似乎能夠對電子郵件、對話文本、小說、新聞、訴訟紀錄等等的文字資訊做總結，真是不錯 !示範Case 1: 新聞內文: 快新聞-台灣正式申請加入cptpp-蔡英文-遞件就代表有信心總結: 23日，蔡英文宣布申請正式的《太平洋全面進步協定》。需要11名成員國人同意，成功人才參與。蔡英文強調：“台灣對外貿易的重要戰略目標！”看起來效果還不錯，從總結結果可以大概知道這篇新聞的大意。Case 2: PTT 對話內文: 〈台申請CPTPP〉澳洲：須基於一個中國原則 態度審慎總結: 台灣嘲諷“中國”和“台灣”“互相”有一系列觀點。台灣“相互”尊重“中國”和“台灣”，台灣尊重“中國”和“台灣”。台灣“相互”尊重“中國”和“台灣”，台灣尊重“中國”和“台灣”。看起來 ptt 鄉民的留言可能太雜亂了，也有可能對話文本的輸入格式與該模型曾經看過的資料有落差，導致效果不佳。Case 3: 電子郵件內文: 最近被 Taiwan AI Labs 招去，來了一封人資信，不好意思被我拿來 demo 用了。總結: 台灣 AI LABS 的 NLP 工程師受聘為 TW AI LABS 建立團隊。尋找頂尖人才開發世界一流的人工智能研究人員和產品。人資的這封信在 ELYZA DIGEST 面前，似乎總結的還算可以接受，代表人資寫得好，還是代表總結的好呢?結語哪天有機會要現場展示，這個或許可以當作我的口袋名單！個人較少接觸到文本摘要任務，對於其中的演算法、邏輯、模型架構等等不熟悉，恰好因為部長時不時會丟出一些東西分享給大家，我才稍稍接觸到，或許自己應該多伸出一些觸角，主動觸及各個領域才是 !" }, { "title": "2012. Sum of Beauty in the Array", "url": "/posts/2012-sum-of-beauty-in-the-array/", "categories": "Leetcode, An-Apple-Per-Day", "tags": "leetcode, medium, array", "date": "2021-09-24 10:00:00 +0800", "snippet": "Leetcode #2012題目描述You are given a 0-indexed integer array nums.For each index i (1 &amp;lt;= i &amp;lt;= nums.length - 2) the beauty of nums[i] equals: 2, if nums[j] &amp;lt; nums[i] &amp;lt; nums[k], for all 0 &amp;lt;= j &amp;lt; i and for all i &amp;lt; k &amp;lt;= nums.length - 1. 1, if nums[i - 1] &amp;lt; nums[i] &amp;lt; nums[i + 1], and the previous condition is not satisfied. 0, if none of the previous conditions holds.Return the sum of beauty of all nums[i] where 1 &amp;lt;= i &amp;lt;= nums.length - 2.白話文運動請回傳一個一維陣列 nums 在 1 &amp;lt;= i &amp;lt;= nums.length - 2 的漂亮總和。什麼是漂亮呢？在一維陣列中 (1 &amp;lt;= i &amp;lt;= nums.length - 2)，nums[i] 的漂亮值為: 2, if nums[j] &amp;lt; nums[i] &amp;lt; nums[k], for all 0 &amp;lt;= j &amp;lt; i and for all i &amp;lt; k &amp;lt;= nums.length - 1. 1, if nums[i - 1] &amp;lt; nums[i] &amp;lt; nums[i + 1], 且第一個條件不滿足的前提之下。 0, 且上述兩個條件都不滿足的前提之下。題目限制 3 &amp;lt;= nums.length &amp;lt;= 105 看到這麼長的長度，基本上時間複雜度必須為 O(N) 1 &amp;lt;= nums[i] &amp;lt;= 105 具體測資Case 1Input: nums = [1,2,3]Output: 2Explanation: For each index i in the range 1 &amp;lt;= i &amp;lt;= 1:- The beauty of nums[1] equals 2.Case 2Input: nums = [2,4,6,4]Output: 1Explanation: For each index i in the range 1 &amp;lt;= i &amp;lt;= 2:- The beauty of nums[1] equals 1.- The beauty of nums[2] equals 0.Case 3Input: nums = [3,2,1]Output: 0Explanation: For each index i in the range 1 &amp;lt;= i &amp;lt;= 1:- The beauty of nums[1] equals 0.解題想法概念滿足第一個漂亮條件的前提是，當前的 nums[i] 必須大於之前的數字、小於之後的數字，因此，我認為需要額外製作兩個矩陣，分別紀錄當前數字的左邊最大值與右邊最小值。稍待片刻，消化一下。只要當前數字大於左邊最大值，那麼，當前數字就大於左邊所有數字了！同理，當前數字小於右邊最小值，那麼，當前數字就小於右邊所有數字了！那麼，我們只需要分別寫一個迴圈，遍歷nums中的元素即可得到這兩個矩陣，時間複雜度只有O(N)唷！另外，第二個漂亮條件相對簡單，遍歷nums即可完成。舉例來說:nums = [1, 2, 3, 9, 5, 6, 7 ]left_max = [0, 1, 2, 3, 9, 9, 0 ]right_min = [inf, 3, 5, 5, 6, 7, inf]beauty = [x, 2, 2, 0, 0, 1, x ]ret = 2 + 2 + 0 + 0 + 1 = 5Pseudo CodeGIVEN: nums is a 1D array.SET n is len(nums).SET left_max is a n size 1D array where all elements are zero.SET right_min is a n size 1D array where all elements are float(&#39;inf&#39;).SET ret is a empty list. ## create left_max listFOR i (1 to n-1) do IF nums[i-1] &amp;gt; left_max[i-1] do left_max[i] &amp;lt;- nums[i-1] ELSE left_max[i] &amp;lt;- left_max[i-1] ENDIFENDFOR ## create right_min listFOR i (n-2 to 0) do IF nums[i+1] &amp;lt; right_min[i+1] do right_min[i] &amp;lt;- nums[i+1] ELSE right_min[i] &amp;lt;- right_min[i+1] ENDIFENDFOR## collect ansFOR i in (1 to n-1) do IF left_max[i] &amp;lt; nums[i] &amp;lt; right_min[i] do ret &amp;lt;- ret + 2 ELIF nums[i-1] &amp;lt; nums[i] &amp;lt; nums[i+1] do ret &amp;lt;- ret + 1 ENDIFENDFORRETURN ret複雜度分析 時間複雜度: O(n) 空間複雜度: O(n)實際解題Pythonclass Solution: def sumOfBeauties(self, nums: List[int]) -&amp;gt; int: n = len(nums) ## create left_max list left_max = [0] * n for i in range(1, n-1, 1): if nums[i-1] &amp;gt; left_max[i-1]: left_max[i] = nums[i-1] else: left_max[i] = left_max[i-1] ## create right_min list right_min = [float(&quot;inf&quot;)] * n for i in range(n-2, 0, -1): if nums[i+1] &amp;lt; right_min[i+1]: right_min[i] = nums[i+1] else: right_min[i] = right_min[i+1] ## collect ans ret = 0 for i in range(1, n-1, 1): if left_max[i] &amp;lt; nums[i] &amp;lt; right_min[i]: ret += 2 elif nums[i-1] &amp;lt; nums[i] &amp;lt; nums[i+1]: ret += 1 return ret討論區寫了 40 分鐘，後來跟討論區的解法雷同，真是開心 :)" }, { "title": "1992. Find All Groups of Farmland", "url": "/posts/1992-find-all-groups-of-farmland/", "categories": "Leetcode, An-Apple-Per-Day", "tags": "leetcode, medium, dfs", "date": "2021-09-23 11:00:00 +0800", "snippet": "Leetcode #1992題目描述You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.白話文運動給定一個 m x n 的二維陣列，其中元素由 0 與 1 組成。在二維陣列中，由 1 組成了矩形區域 (不同矩形區域，左右上下不相鄰)。每個矩形區域由左上座標[r1, c1]與右下座標[r2, c2]代表之，形成 [r1, c1, r2, c2]。請回傳所有的矩形區域。題目限制 m == land.length n == land[i].length 1 &amp;lt;= m, n &amp;lt;= 300 land consists of only 0’s and 1’s. Groups of farmland are rectangular in shape.具體測資Case 1Input: land = [[1,0,0],[0,1,1],[0,1,1]]Output: [[0,0,0,0],[1,1,2,2]]Explanation:The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].Case 2Input: land = [[1,1],[1,1]]Output: [[0,0,1,1]]Explanation:The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].Case 3Input: land = [[0]]Output: []Explanation:There are no groups of farmland.解題想法概念遍歷二維陣列，並使用深度優先搜索 (DFS, Depth-First Search)探索矩形區域之右下座標(座標最大值)。Pseudo CodeGIVEN: land is a 2D array.SET m is len(land).SET n is len(land[0]).SET visited_map is a 2D (mxn) array where all elements are False.SET ret is a empty list.FUNC dfs(i, j) do IF i &amp;gt;= m or i &amp;lt; 0 or j &amp;gt;= n or j &amp;lt; 0: RETURN (0, 0) ENDIF IF visited_map[i][j]: RETURN (0, 0) ENDIF IF land[i][j] == 0: RETURN (0, 0) ENDIF visited_map[i][j] = True RETURN max((i, j), dfs(i+1, j), dfs(i, j+1))ENDFUNCFOR i (0 to m) do FOR j (0 to n) do IF not visited_map[i][j] do IF land[i][j] == 1 do (p, q) &amp;lt;- dfs(i, j) ret &amp;lt;- ret + [i, j, p, q] ELSE visited_map[i][j] &amp;lt;- True ENDIF ENDIF ENDFORENDFORRETURN ret複雜度分析 時間複雜度: O(m*n) 空間複雜度: O(1) (不考慮回傳時所創建的矩陣) 實際解題Pythonclass Solution: def findFarmland(self, land: List[List[int]]) -&amp;gt; List[List[int]]: m = len(land) n = len(land[0]) visited_map = [[False] * n for _ in range(m)] ## 以 (i, j) 為矩形左上座標之視角，遍歷出矩形右下座標 def dfs(i: int, j: int): if i &amp;gt;= m or i &amp;lt; 0 or j &amp;gt;= n or j &amp;lt; 0: return (0, 0) if visited_map[i][j]: return (0, 0) if land[i][j] == 0: return (0, 0) visited_map[i][j] = True return max((i, j), dfs(i+1, j), dfs(i, j+1)) ret = list() for i in range(m): for j in range(n): ## 如果 (i, j) 還未遍歷過 if not visited_map[i][j]: ## 此時該點必為矩形左上座標 if land[i][j] == 1: ## 找尋與該點配對之右下座標 (p, q) = dfs(i, j) ret.append([i, j, p, q]) else: visited_map[i][j] = True return ret討論區" }, { "title": "Weekly Progress (39th / 2021)", "url": "/posts/39th-weekly-progress/", "categories": "WeeklyProgress, 2021", "tags": "weeklyprogress", "date": "2021-09-22 16:40:00 +0800", "snippet": "本週適逢中秋節，且是第一次在這裡分享我每週計畫與完成狀況，因此許多事情尚未確定，但期許自己持續寫下去！每天超越自己一點點，回首時會驚訝自己走了那麼遠。Ganttgantt title 39-th week (2021) dateFormat YYYY-MM-DD axisFormat %m/%d section Leetcode 1992 exercise : done , L1, 2021-09-22, 1d 1992 writing : done , L2, 2021-09-22, 1d 2011 exercise : done , L3, 2021-09-23, 1d 2011 writing : L4, 2021-09-23, 1d 2012 exercise : done , L5, 2021-09-24, 1d 2012 writing : done , L6, 2021-09-24, 1d 2013 exercise : done , L7, 2021-09-25, 1d 2013 writing : L8, 2021-09-25, 1d section Blog experience your life: done, B1, 2021-09-19, 7d writing a life post : active, B2, 2021-09-20, 3d reading a paper/tech post: done, B3, 2021-09-20, 5d writing a tech post : done, B4, 2021-09-22, 3d從今年三月開始，每天固定刷一題 Leetcode，因此，持續這習慣對我來說並不困難，只需提前規劃要寫哪一題而已。但是之前沒有寫部落格的習慣，也知道自己消化文字、產出文字的速度並不快，因此之後或許還會有些調整。不過，我用 Mark Zuckerberg 的名言鼓舞自己: Ideas don’t come out fully formed, they only become clearer as you work on them. You just have to get started." }, { "title": "1996. The Number of Weak Characters in the Game", "url": "/posts/1996-the-number-of-weak-characters-in-the-game/", "categories": "Leetcode, An-Apple-Per-Day", "tags": "leetcode, medium, array", "date": "2021-09-17 13:40:00 +0800", "snippet": "Leetcode #1996題目描述You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense.You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.A character is said to be weak if any other character has both attack and defense levels strictly greater than this character’s attack and defense levels.More formally, a character i is said to be weak if there exists another character j where attackj &amp;gt; attacki and defensej &amp;gt; defensei.Return the number of weak characters.白話文運動給定一個二維矩陣，矩陣內的每個元素皆由一維陣列組成: 攻擊 and 防禦。所謂弱元素，意思是其攻擊與防禦值都比某個元素還要小。請回傳弱元素的數量。題目限制 2 &amp;lt;= properties.length &amp;lt;= 105 properties[i].length == 2 1 &amp;lt;= attacki, defensei &amp;lt;= 105具體測資Case 1Input : properties = [[5,5],[6,3],[3,6]]Output : 0Explanation: No character has strictly greater attack and defense than the other.Case 2Input : properties = [[2,2],[3,3]]Output : 1Explanation: The first character is weak because the second character has a strictly greater attack and defense.Case 3Input : properties = [[1,5],[10,4],[4,3]]Output : 1Explanation: The third character is weak because the second character has a strictly greater attack and defense.Case 4Input : properties = [[5,5],[6,7],[5,6],[3,8],[3,4],[2,2]]Output : 4解題想法概念暴力法 遍歷整個二維矩陣，進行兩兩比對。快速解決法 排序 確保二為矩陣的順序，攻擊值由大至小遞減排列、防禦值由小至大遞增排列。 properties = [[5,5],[6,7],[5,6],[3,8],[3,4],[2,2]] sorted_pro = [[6,7],[5,5],[5,6],[3,4],[3,8],[2,2]] 遍歷排序的二維矩陣 遍歷時，因為攻擊值由大至小遞減排列，因此，只需判斷當前元素的防禦值是否比當前最大防禦值還要小，即可判定當前元素是否微弱元素。 若較小，則當前元素即為弱元素。 若較大，則更新最大防禦值。 舉例來說: sorted_pro = [[6,7],[5,5],[5,6],[3,4],[3,8],[2,2]] ----- curr_max_defense = 0 [[6,7],[5,5],[5,6],[3,4],[3,8],[2,2]] ^ ----- curr_max_defense = 7 [[6,7],[5,5],[5,6],[3,4],[3,8],[2,2]] ^ weak ----- curr_max_defense = 7 [[6,7],[5,5],[5,6],[3,4],[3,8],[2,2]] ^ weak ----- curr_max_defense = 7 [[6,7],[5,5],[5,6],[3,4],[3,8],[2,2]] ^ weak ----- curr_max_defense = 7 [[6,7],[5,5],[5,6],[3,4],[3,8],[2,2]] ^ ----- curr_max_defense = 8 [[6,7],[5,5],[5,6],[3,4],[3,8],[2,2]] ^ weak Pseudo CodeGIVEN: properties is a 2D array.## Sort by attack value descendingly and sort by defense value ascendinglysorted_properties &amp;lt;- Sort(properties)## Iterate sorted_properties to count weak elementsSET cuur_max_defense is 0.SET ret is 0.FOR each (attack, defense) of sorted_properties do IF d &amp;lt; curr_max_defense do ret &amp;lt;- ret + 1 ELSE curr_max_defense &amp;lt;- d ENDIFENDFORRETURN ret複雜度分析 時間複雜度: O(NlogN) 排序的平均時間複雜度為 O(NlogN)。 遍歷的時間複雜度為 O(N)。 空間複雜度: O(1)實際解題Pythonclass Solution: def numberOfWeakCharacters(self, properties: List[List[int]]) -&amp;gt; int: sorted_p = sorted(properties, key=lambda k: (-k[0], k[1])) ret = 0 curr_max = 0 for _, d in sorted_p: if d &amp;lt; curr_max: ret += 1 else: curr_max = d return ret討論區與上述想法一致。" }, { "title": "1647. Minimum Deletions to Make Character Frequencies Unique", "url": "/posts/1647-minimum-deletions-to-make-character-frequencies-unique/", "categories": "Leetcode, An-Apple-Per-Day", "tags": "leetcode, medium, string, hashmap", "date": "2021-09-16 16:20:00 +0800", "snippet": "Leetcode #1647題目描述A string s is called good if there are no two different characters in s that have the same frequency.Given a string s, return the minimum number of characters you need to delete to make s good.The frequency of a character in a string is the number of times it appears in the string. For example, in the string “aab”, the frequency of ‘a’ is 2, while the frequency of ‘b’ is 1.白話文運動有一字串 s 若被稱為好字串，代表字串中的字元頻率必唯一。反之，若被稱為壞字串，那麼，請回傳最少執行幾次刪除操作(一次只能刪除一個字元)，才可以讓字串改邪歸正。所謂字元頻率，是字元在字串中出現的次數。舉例來說，”aab” 字串中，”a” 的字元頻率為 2，”b” 的字元頻率為 1。題目限制 1 &amp;lt;= s.length &amp;lt;= 105 s contains only lowercase English letters.具體測資Case 1Input : s = &quot;aab&quot;Output : 0 Explanation : s is already goodCase 2Input : s = &quot;aaabbbccc&quot;Output : 2Explanation : You can delete two &#39;b&#39;s resulting in the good string &quot;aaabcc&quot;.Another way it to delete one &#39;b&#39; and one &#39;c&#39; resulting in the good string &quot;aaabbc&quot;.Case 3Input : s = &quot;ceabaacb&quot;Output : 2Explanation : You can delete both &#39;c&#39;s resulting in the good string &quot;eabaab&quot;.Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).解題想法概念 計算字元頻率 在進行刪除操作之前，須先掌握字串中的各個字元頻率，因此一開始應先思考如何計算字元頻率。 我的想法是建立一個 hashmap，裡頭存放 key:value，意即 字元:字元個數。此時，取得特定字元的字元頻率所花費的時間複雜度僅需 O(1)，且取用方便。 貪婪演算法計算最少刪除操作次數 本題無需特別注意 corner case，因此採用貪婪法 (greedy algorithm)的想法，來計算最少需執行幾次的刪除操作，才可讓字串成為好字串。 遍歷整個 hashmap，每當遇到重複的字元頻率，將其刪除之，並計一次刪除操作，直至沒有與其他字元重複頻率或是字元完全被消除殆盡。 Pseudo CodeGIVEN: s is an input string.## Create hashmap to record frequency of character of stringSET hashmap is a dictionary.FOR each character c of s do hashmap[c] &amp;lt;- hashmap[c] + 1 ENDFOR## Greedy algorithmSET cnt_tmp is a list.SET ret is 0.FOR each count cnt of hashmap do WHILE cnt &amp;gt; 0 and cnt in cnt_tmp cnt &amp;lt;- cnt - 1 ret &amp;lt;- ret + 1 ENDWHILE cnt_tmp &amp;lt;- cnt_tmp + [cnt]ENDFORRETURN ret複雜度分析 時間複雜度: O(N) 第一個 For 迴圈，建立 hashmap 時，需要遍歷整個字串，時間複雜度為 O(N)。 第二個 For 迴圈，衡量該刪除哪一個字元時，需要遍歷整個 hashmap，而因為 key 頂多只有 26 個小寫字母，相應的 value 也最多只有 26 個不同的字元頻率，因此不論是外層的 For 迴圈或是內層的 While 迴圈，時間複雜度需要 O(1)。 空間複雜度: O(1) 建立 hashmap 最多只會有 26 個字母作為 key，因此，空間複雜度為 O(1)。 建立 cnt_tmp 最多只會有 26 個不同的字元頻率，因此，空間複雜度為 O(1)。 實際解題Pythonclass Solution: def minDeletions(self, s: str) -&amp;gt; int: ## Create hashmap to record frequency of character of string hash_map = dict() for c in s: if c not in hash_map: hash_map[c] = 1 else: hash_map[c] += 1 ## Greedy algorithm cnt_tmp = list() ret = 0 for c, cnt in hash_map.items(): while cnt &amp;gt; 0 and cnt in cnt_tmp: cnt -= 1 ret += 1 cnt_tmp.append(cnt) return ret討論區與上述想法一致。" } ]
